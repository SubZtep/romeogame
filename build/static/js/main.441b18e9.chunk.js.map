{"version":3,"sources":["components/ModelCanvas.tsx","components/DebugCanvas.tsx","components/PoseNet.tsx","components/App.tsx","serviceWorker.ts","index.tsx"],"names":["lookAtCtl","sphere","mesh","skeleton","scene","engine","canvas","toTuple","x","y","DebugCanvas","props","canvasContext","pointRadius","minPartConfidence","scale","skeletonColor","skeletonLineWidth","ref","React","keypoints","length","current","getContext","clearRect","width","height","forEach","keypoint","score","position","beginPath","arc","Math","PI","fillStyle","fill","posenet","color","lineWidth","firstX","firstY","nextX","nextY","moveTo","lineTo","strokeStyle","stroke","drawSegment","className","onAvatarImported","meshes","particleSystems","skeletons","animationGroups","scaling","BABYLON","CreateSphere","diameter","bones","adjustYaw","adjustRoll","initBabylon","e","camera","setTarget","attachControl","ImportMesh","runRenderLoop","render","onSceneMount","onResizeWindow","resize","ModelCanvas","window","addEventListener","removeEventListener","nose","find","point","part","head_bone","registerBeforeRender","round","z","update","moveAvatar","attrs","c","PoseNet","posenetModel","videoWidth","videoHeight","flipHorizontal","minPoseConfidence","webcamRef","setKeypoints","loadPoseNet","a","architecture","outputStride","inputResolution","quantBytes","multiplier","Error","poseDetectionFrame","video","findPoseDetectionFrame","estimateSinglePose","pose","requestAnimationFrame","style","audio","mirrored","onUserMedia","App","Boolean","location","hostname","match","ReactDOM","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.441b18e9.chunk.js","sourcesContent":["import * as React from \"react\"\nimport * as BABYLON from \"babylonjs\"\nimport * as posenet from \"@tensorflow-models/posenet\"\n\n/** Look at controller */\nlet lookAtCtl: BABYLON.BoneLookController\n\n/** Sphere to look at */\nlet sphere: BABYLON.Mesh\n\n/** Avatar mesh */\nlet mesh: BABYLON.AbstractMesh\n\n/** Avatar skeleton */\nlet skeleton: BABYLON.Skeleton\n\nconst moveAvatar = (keypoints: posenet.Keypoint[]) => {\n  const nose = (keypoints.find(point => point.part === \"nose\") as posenet.Keypoint).position\n  const head_bone = skeleton.bones[7]\n\n  scene.registerBeforeRender(() => {\n    //FIXME: Tweak me\n    sphere.position.x = head_bone.position.x + Math.round((640 / 2 - nose.x) / 20)\n    sphere.position.y = head_bone.position.x + Math.round((480 / 2 - nose.y) / 20)\n    sphere.position.z = 6\n\n    lookAtCtl.update()\n  })\n}\n\nconst onAvatarImported = (\n  meshes: BABYLON.AbstractMesh[],\n  particleSystems: BABYLON.IParticleSystem[],\n  skeletons: BABYLON.Skeleton[],\n  animationGroups: BABYLON.AnimationGroup[]\n) => {\n  const scaleAmount = 0.1\n  meshes[0].scaling = new BABYLON.Vector3(scaleAmount, scaleAmount, scaleAmount)\n\n  mesh = meshes[0]\n  skeleton = skeletons[0]\n  sphere = BABYLON.MeshBuilder.CreateSphere(\"\", { diameter: 0.0001 }, scene)\n\n  lookAtCtl = new BABYLON.BoneLookController(mesh, skeleton.bones[7], sphere.position, {\n    adjustYaw: Math.PI * 0.5,\n    adjustRoll: Math.PI * 0.5\n  })\n}\n\nconst onSceneMount = (e: SceneEventArgs) => {\n  const { canvas, scene, engine } = e\n\n  var camera = new BABYLON.FreeCamera(\"camera1\", new BABYLON.Vector3(0, 5, 11), scene)\n  camera.setTarget(new BABYLON.Vector3(0, 3.5, 0))\n  camera.attachControl(canvas, true)\n  new BABYLON.HemisphericLight(\"light1\", new BABYLON.Vector3(0, 1, 0), scene)\n  //BABYLON.Mesh.CreateGround(\"ground1\", 6, 6, 2, scene)\n\n  // Load Dude model\n  BABYLON.SceneLoader.ImportMesh(\"him\", \"/models/Dude/\", \"dude.babylon\", scene, onAvatarImported)\n\n  engine.runRenderLoop(() => {\n    if (scene) {\n      scene.render()\n    }\n  })\n}\n\nlet scene: BABYLON.Scene\nlet engine: BABYLON.Engine\nlet canvas: HTMLCanvasElement\n\nconst initBabylon = () => {\n  if (!engine) {\n    engine = new BABYLON.Engine(canvas, true)\n    scene = new BABYLON.Scene(engine)\n    onSceneMount({\n      scene,\n      engine,\n      canvas\n    })\n  }\n}\n\nconst onResizeWindow = () => {\n  if (engine) {\n    engine.resize()\n  }\n}\n\nexport type SceneEventArgs = {\n  engine: BABYLON.Engine\n  scene: BABYLON.Scene\n  canvas: HTMLCanvasElement\n}\n\nexport type SceneProps = {\n  width?: number\n  height?: number\n  keypoints?: posenet.Keypoint[]\n}\n\nconst ModelCanvas: React.FC<SceneProps & React.HTMLAttributes<HTMLCanvasElement>> = props => {\n  const { width = 640, height = 480 } = props // eslint-disable-line\n\n  React.useEffect(() => {\n    initBabylon()\n    window.addEventListener(\"resize\", onResizeWindow)\n    return () => {\n      window.removeEventListener(\"resize\", onResizeWindow)\n    }\n  }, [])\n\n  React.useEffect(() => {\n    if (props.keypoints && props.keypoints.length > 0) {\n      moveAvatar(props.keypoints)\n    }\n  }, [props.keypoints])\n\n  const onCanvasLoaded = (c: HTMLCanvasElement) => {\n    if (c !== null) {\n      canvas = c\n    }\n  }\n\n  const attrs = {\n    width: props.width,\n    height: props.height\n  }\n  return <canvas {...attrs} ref={onCanvasLoaded} />\n}\n\nexport default ModelCanvas\n","import * as React from \"react\"\nimport * as posenet from \"@tensorflow-models/posenet\"\n\nconst drawSegment = (\n  [firstX, firstY]: number[],\n  [nextX, nextY]: number[],\n  color: string,\n  lineWidth: number,\n  scale: number,\n  canvasContext: CanvasRenderingContext2D\n) => {\n  canvasContext.beginPath()\n  canvasContext.moveTo(firstX * scale, firstY * scale)\n  canvasContext.lineTo(nextX * scale, nextY * scale)\n  canvasContext.lineWidth = lineWidth\n  canvasContext.strokeStyle = color\n  canvasContext.stroke()\n}\n\nconst toTuple = ({ x, y }: { x: number; y: number }): [number, number] => {\n  return [x, y]\n}\n\ninterface IDebugCanvasState {\n  width: number\n  height: number\n  keypoints: posenet.Keypoint[]\n  pointRadius?: number\n  //minPoseConfidence?: number\n  minPartConfidence?: number\n  scale?: number\n  skeletonColor?: string\n  skeletonLineWidth?: number\n}\n\nconst DebugCanvas: React.FC<IDebugCanvasState> = props => {\n  const {\n    pointRadius = 3,\n    //minPoseConfidence = 0.1,\n    minPartConfidence = 0.5,\n    scale = 1,\n    skeletonColor = \"#ffadea\",\n    skeletonLineWidth = 6\n  } = props\n\n  const ref = React.useRef<HTMLCanvasElement>(null)\n  let canvasContext: CanvasRenderingContext2D\n\n  const refreshCanvas = () => {\n    if (props.keypoints.length === 0) return\n    if (!canvasContext) {\n      if (ref.current === null) return\n      canvasContext = ref.current.getContext(\"2d\") as CanvasRenderingContext2D\n    }\n\n    // Clear Canvas\n    canvasContext.clearRect(0, 0, props.width, props.height)\n\n    // Draw Keypoints\n    props.keypoints.forEach(keypoint => {\n      if (keypoint.score >= minPartConfidence) {\n        const { x, y } = keypoint.position\n        canvasContext.beginPath()\n        canvasContext.arc(x * scale, y * scale, pointRadius, 0, 2 * Math.PI)\n        canvasContext.fillStyle = skeletonColor\n        canvasContext.fill()\n      }\n    })\n\n    // Draw Skeleton\n    const adjacentKeyPoints = posenet.getAdjacentKeyPoints(props.keypoints, minPartConfidence)\n    adjacentKeyPoints.forEach(keypoints => {\n      drawSegment(\n        toTuple(keypoints[0].position),\n        toTuple(keypoints[1].position),\n        skeletonColor,\n        skeletonLineWidth,\n        scale,\n        canvasContext\n      )\n    })\n  }\n\n  React.useEffect(refreshCanvas, [props.keypoints])\n\n  return <canvas ref={ref} width={props.width} height={props.height} className=\"absolute\" />\n}\n\nexport default DebugCanvas\n","import * as React from \"react\"\nimport * as posenet from \"@tensorflow-models/posenet\"\nimport Webcam from \"react-webcam\"\nimport DebugCanvas from \"./DebugCanvas\"\nimport ModelCanvas from \"./ModelCanvas\"\n\ninterface IPoseNetProps {\n  videoWidth?: number\n  videoHeight?: number\n  flipHorizontal?: boolean\n  minPoseConfidence?: number\n}\n\nconst PoseNet: React.FC<IPoseNetProps> = props => {\n  const {\n    videoWidth = 640,\n    videoHeight = 480,\n    flipHorizontal = true,\n    minPoseConfidence = 0.1\n  } = props\n  const webcamRef = React.useRef<Webcam>(null)\n  let posenetModel: posenet.PoseNet\n\n  const [keypoints, setKeypoints] = React.useState<posenet.Keypoint[]>([])\n\n  const loadPoseNet = async () => {\n    try {\n      posenetModel = await posenet.load({\n        architecture: \"ResNet50\",\n        outputStride: 32,\n        inputResolution: 257,\n        quantBytes: 2,\n        multiplier: 1\n      })\n    } catch (error) {\n      throw new Error(\"PoseNet failed to load\")\n    }\n    poseDetectionFrame()\n  }\n\n  const poseDetectionFrame = () => {\n    const video = (webcamRef.current as Webcam).video as HTMLVideoElement\n    video.width = videoWidth\n    video.height = videoHeight\n\n    const findPoseDetectionFrame = async () => {\n      const pose = await posenetModel.estimateSinglePose(video, {\n        flipHorizontal\n      })\n\n      if (pose.score >= minPoseConfidence) {\n        setKeypoints(pose.keypoints)\n      }\n\n      requestAnimationFrame(findPoseDetectionFrame)\n    }\n    findPoseDetectionFrame()\n  }\n\n  return (\n    <div className=\"flex\">\n      <div className=\"relative\" style={{ width: videoWidth, height: videoHeight }}>\n        <Webcam\n          audio={false}\n          mirrored={true}\n          onUserMedia={loadPoseNet}\n          ref={webcamRef}\n          className=\"absolute\"\n        />\n        <DebugCanvas width={videoWidth} height={videoHeight} keypoints={keypoints} />\n      </div>\n      <ModelCanvas width={videoWidth} height={videoHeight} keypoints={keypoints} />\n    </div>\n  )\n}\n\nexport default PoseNet\n","import * as React from \"react\"\nimport PoseNet from \"./PoseNet\"\n\nconst App: React.FC = () => {\n  return (\n    <div className=\"container mx-auto bg-gray-100\">\n      <PoseNet />\n    </div>\n  )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\n//import \"./index.css\"\nimport App from \"./components/App\"\nimport * as serviceWorker from \"./serviceWorker\"\n\nReactDOM.render(<App />, document.getElementById(\"root\"))\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n"],"sourceRoot":""}